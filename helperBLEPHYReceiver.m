classdef helperBLEPHYReceiver < handle
%helperBLEPHYReceiver Create an object for BLE PHY receiver
%   BLEPHYRX = helperBLEPHYReceiver creates a BLE PHY receiver object
%   supporting all the four PHY decoding modes (LE1M, LE2M, LE500K and
%   LE125K).
%
%   BLEPHYRX = helperBLEPHYReceiver(Name, Value) creates a BLE PHY receiver
%   object with the specified property Name set to the specified Value. You
%   can specify additional name-value pair arguments in any order as
%   (Name1, Value1, ..., NameN, ValueN).
%
%   helperBLEPHYReceiver properties:
%
%   ChannelIndex        - BLE channel index for receiving the link layer
%                         (LL) PDU
%   NoiseFigure         - Noise figure in dB
%   PHYMode             - Specifies the PHY decoding mode
%   AccessAddress       - Unique connection address

%   Copyright 2019 The MathWorks, Inc.

properties
    %ChannelIndex BLE channel index for receiving the LL PDU
    %   Specify channel index as a scalar integer in the range [0, 39]. It
    %   defines the transmitting channel for LL PDUs. To receive LL data
    %   PDUs, channels 0 to 36 are used. Whereas, channels 37, 38 and 39
    %   are used to receive LL advertising PDUs. The default value is 37
    %   (advertising channel).
    ChannelIndex = 37
    
    %NoiseFigure Noise figure in dB
    %   Specify the noise figure as a scalar double nonnegative value. It
    %   is used in applying the thermal noise on the received waveform in
    %   dB. The default value is 0 dB.
    NoiseFigure = 0
    
    %PHYMode Specifies the PHY decoding mode
    %   Specify the PHY mode based on the data rate as 'LE1M' | 'LE2M' |
    %   'LE500K' or 'LE125K'. It specifies the PHY decoding mode. Refer
    %   Bluetooth Core Specification version 5.1, volume 6, part B, section
    %   2.
    PHYMode = 'LE1M'
    
    %AccessAddress Unique connection address
    %   Specify the access address as a 32-element binary column vector
    %   denoting a 4-octet access address value. This property indicates a
    %   unique 32-bit address generated by the LL for the new connection or
    %   for a periodic advertisement between two BLE nodes. The default
    %   value is 32 zeros.
    AccessAddress = zeros(32, 1)
end

properties(Hidden)
    %SamplesPerSymbol Number of samples per symbol
    %   Specifies the samples per symbol as a scalar positive integer. The
    %   default value is 20.
    SamplesPerSymbol = 20
end

properties (Constant, Hidden)
    % PHY mode values
    PHYModeValues = {'LE1M', 'LE2M', 'LE500K', 'LE125K'}
    
    % Maximum number of IQ samples for a single waveform in LE1M mode
    % (considered up to 100 samples per symbol)
    WaveformMaxSize = 40000
    
    % Maximum number of interfered signals to be stored
    InterferedSignalsCount = 50
end

properties (Access = private)    
    %pReceptionTimer Timer for receiving an LL PDU (in microseconds)
    pReceptionTimer = 0
    
    %pInterferedSignals Buffer to store the interfered signals
    pInterferedSignals
end

properties (SetAccess = private)
    %pProcessing Flag to specify the waveform is processing in the PHY
    pProcessing = false
end

properties (SetAccess = private, Hidden)
    %pDuration Duration for receiving the LL PDU (in microseconds)
    pDuration = 0
    
    %pStatus Status of the LL PDU reception (either 0 | 1 | 2 )
    % 0 - Not started
    % 1 - RxStart
    % 2 - RxEnd
    pStatus = 0
    
    %pSignal Received BLE waveform along with metadata
    pSignal
end

properties (SetAccess = private)    
    %ReceivedSignals Number of signals received
    ReceivedSignals = 0
    
    %ReceivedBits Number of bits received and successfully decoded
    ReceivedBits = 0
    
    %TotalCollisions Total number of collisions occurred
    % Multiple signals collide with the actual signal is considered as one
    % collision
    TotalCollisions = 0
    
    %TwoSignalsCollision Number of collisions occurred
    % Two signals collide with the actual signal is considered as one
    % collision
    TwoSignalsCollision = 0
    
    %ThreeSignalsCollision Number of collisions occurred
    % Three signals collide with the actual signal is considered as one
    % collision
    ThreeSignalsCollision = 0
    
    %FourSignalsCollision Number of collisions occurred
    % Four signals collide with the actual signal is considered as one
    % collision
    FourSignalsCollision = 0
end

properties (Dependent, SetAccess = private)
    %SampleRate Sample rate of the received waveform
    %   Sample rate of BLE waveform is depends on <a
    %   href="matlab:help('helperBLEPHYReceiver.PHYMode')">PHYMode</a> and <a
    %   href="matlab:help('helperBLEPHYReceiver.SamplesPerSymbol')">SamplesPerSymbol</a>.
    %   It is represented in samples per second.
    SampleRate
end

methods
    % Constructor
    function obj = helperBLEPHYReceiver(varargin)
        % Set name-value pairs
        for idx = 1:2:nargin
            obj.(varargin{idx}) = varargin{idx+1};
        end
        % Initialize the BLE signal
        obj.pSignal = struct('Waveform', complex(zeros(obj.WaveformMaxSize, 1)), ...
                             'NumSamples', 0, ...
                             'SampleRate', 0, ...
                             'SamplesPerSymbol', 0, ...
                             'StartTime', 0, ...
                             'EndTime', 0);
        % Initialize the buffer for storing the interfered signals
        obj.pInterferedSignals = repmat(obj.pSignal, 1, obj.InterferedSignalsCount);
    end
    
    % Auto-completion for fixed set of option strings
    function v = set(obj, prop)
        v = obj.([prop, 'Values']);
    end
    
    % Set channel index
    function set.ChannelIndex(obj, value)
        validateattributes(value, {'numeric'}, {'scalar', ...
            'integer', '>=', 0, '<=', 39}, mfilename, 'ChannelIndex');
        obj.ChannelIndex = value;
    end
    
    % Set PHY mode
    function set.PHYMode(obj, value)
        obj.PHYMode = validatestring(value, obj.PHYModeValues, ...
            mfilename, 'PHYMode');
    end
    
    % Set access address
    function set.AccessAddress(obj, value)
        validateattributes(value, {'numeric'}, {'column', 'binary', ...
            'numel', 32}, mfilename, 'AccessAddress');
        obj.AccessAddress = value;
    end
    
    % Set noise figure in dB
    function set.NoiseFigure(obj, value)
        validateattributes(value, {'numeric'}, {'real', 'scalar', ...
            'nonnegative'}, mfilename, 'NoiseFigure');
        obj.NoiseFigure = value;
    end
    
    % Set samples per symbol
    function set.SamplesPerSymbol(obj, value)
        validateattributes(value, {'numeric'}, {'scalar', ...
            'integer', 'positive'}, mfilename, 'SamplesPerSymbol');
        obj.SamplesPerSymbol = value;
    end
    
    function value = get.SampleRate(obj)
        value = 0;
        % PHY mode
        switch obj.PHYMode
            case {'LE1M', 'LE500K', 'LE125K'}
                % 1msps (one mega symbols per second)
                value = 1e6;
            case 'LE2M'
                % 2msps (two mega symbols per second)
                value = 2e6;
        end
        % Multiply with sps (samples per symbol)
        value = value * obj.SamplesPerSymbol;
    end
    
    function [nextInvokeTime, llPDU, accessAddress] = run(obj, elapsedTime, bleSignal)
    %run Process the received BLE signal and returns the decoded LL bits
    %along with the access address
    %
    %   [NEXTINVOKETIME, LLPDU, ACCESSADDRESS] = run(OBJ, ELAPSEDTIME,
    %   BLESIGNAL) decodes the received BLE waveform and returns the link
    %   layer PDU along with the access address.
    %
    %   NEXTINVOKETIME returns the time after which the run function must
    %   be invoked again.
    %
    %   LLPDU returns the decoded LL protocol data unit (PDU) appended with
    %   cyclic redundancy check (CRC) in binary format.
    %
    %   AccessAddress returns the 32-bit access address decoded from the
    %   received BLE waveform.
    %
    %   ELAPSEDTIME is the time elapsed in microseconds between the
    %   previous and current call of this function.
    %
    %   BLESIGNAL is a structure with these fields:
    %       Waveform:         IQ samples of the received waveform
    %       NumSamples:       Length of the waveform (number of IQ samples)
    %       SampleRate:       Sample rate of the received waveform
    %       SamplesPerSymbol: Samples per symbol used while generating the
    %                         waveform
    %       StartTime:        Simulation time in microseconds at the
    %                         waveform entry
    %       EndTime:          Simulation time in microseconds after the
    %                         waveform duration
    %
    %   OBJ is instance of object of type helperBLEPHYReceiver.
    
        % Initialize
        nextInvokeTime = -1;
        llPDU = zeros(1, 0);
        accessAddress = zeros(32, 1);
        
        % PDU is receiving
        if obj.pProcessing
            % Update the reception timer
            obj.pReceptionTimer = obj.pReceptionTimer - elapsedTime;

            % LL PDU duration is completed
            if obj.pReceptionTimer <= 0
                % Apply interference on the received signal
                bleWaveform = applyInterference(obj);
                
                % Apply thermal noise
                bleWaveform = applyThermalNoise(obj, bleWaveform, obj.pSignal.SampleRate);
                
                % Decode the waveform and return the decoded LL PDU along
                % with the access address
                [decodedBits, decodedAccessAddress] = decodeWaveform(obj, bleWaveform);
                
                llPDU = double(decodedBits);
                accessAddress = double(decodedAccessAddress);
                
                % Update the status
                obj.pStatus = 2;
                % Reset the reception flag
                obj.pProcessing = false;
                % Reset the reception timer
                obj.pReceptionTimer = 0;
                % Update the reception statistics
                obj.ReceivedBits = obj.ReceivedBits + numel(decodedBits) + numel(decodedAccessAddress);
            else
                % Received an interfered signal
                if bleSignal.NumSamples ~= 0
                    % Calculate the waveform duration in microseconds
                    waveformDuration = calculateWaveformDuration(obj, bleSignal.NumSamples);
                    % Update the end time of the received BLE signal
                    bleSignal.EndTime = bleSignal.StartTime + waveformDuration;
                    
                    % Get an index in the interfered signals buffer to store
                    % the received interfered signal
                    idx = getStoreIndex(obj);
                    
                    if idx ~= 0
                        % Store the interfered waveform along with updated
                        % metadata
                        obj.pInterferedSignals(idx) = bleSignal;
                    else
                        disp('Interference buffer is full, ignoring the received waveform.');
                    end
                end
                
                % Reset the status
                obj.pStatus = 0;
            end
            % Update next event timer
            nextInvokeTime = obj.pReceptionTimer;
        % No LL PDU is available for reception
        else
            if bleSignal.NumSamples ~= 0
                % Store the received waveform with metadata
                obj.pSignal = bleSignal;
                
                % Update the status
                obj.pStatus = 1;
                % Set the reception flag
                obj.pProcessing = true;
                % Update the received samples per symbol value
                obj.SamplesPerSymbol = bleSignal.SamplesPerSymbol;
                % Calculate the waveform duration in microseconds
                obj.pDuration = calculateWaveformDuration(obj, bleSignal.NumSamples);
                % Set the reception timer to waveform duration time
                obj.pReceptionTimer = obj.pDuration;
                % Update the end time of the received BLE signal
                obj.pSignal.EndTime = obj.pSignal.StartTime + obj.pDuration;
                % Update next event timer
                nextInvokeTime = obj.pReceptionTimer;
                % Update the reception statistics
                obj.ReceivedSignals = obj.ReceivedSignals + 1;
            else
                obj.pStatus = 0;
            end
        end
    end
    
    function waveformDuration = calculateWaveformDuration(obj, numSamples)
    %calculateWaveformDuration Calculate waveform duration based of the
    %number of samples in the received waveform
    %
    %   WAVEFORMDURATION = calculateWaveformDuration(OBJ, NUMSAMPLES)
    %   returns the waveform duration in microseconds based on the number
    %   of samples.
    %
    %   WAVEFORMDURATION returns the duration of the received waveform in
    %   microseconds.
    %
    %   NUMSAMPLES is the number of samples present in the received
    %   waveform.
    %
    %   OBJ is instance of object of type helperBLEPHYReceiver.
    
        % Calculate the waveform duration in microseconds
        waveformDuration = numSamples * (1/obj.SampleRate) * 1e6;
    end
end

methods(Hidden)
    function removeInterferedSignals(obj, startTime)
    %removeInterferedSignals Remove the interfered signals from the stored
    %buffer whose end time is less than the start time of the newly
    %processing waveform
        
        for idx = 1:obj.InterferedSignalsCount
            % Remove the waveform
            if obj.pInterferedSignals(idx).NumSamples ~= 0
                if obj.pInterferedSignals(idx).EndTime < startTime
                    obj.pInterferedSignals(idx).NumSamples = 0;
                end
            end
        end
    end
end

methods (Access = private)    
    function storeIdx = getStoreIndex(obj)
    %getStoreIndex Get an index to store the interfered waveform in the
    %buffer
    
        storeIdx = 0;
        for idx = 1:obj.InterferedSignalsCount
            % Get an index having an empty signal
            if (obj.pInterferedSignals(idx).NumSamples == 0)
                storeIdx = idx;
                break;
            end
        end
    end
    
    function interferedIdxs = getInterferedIdxs(obj, startTime, endTime)
    %getInterferedIdxs Get indexes of the interfered signals from stored
    %buffer using interference start and end times
    
        idxs = zeros(1, obj.InterferedSignalsCount);
        idxCount = 1;
        for idx = 1:obj.InterferedSignalsCount
            % Fetch valid signals
            if obj.pInterferedSignals(idx).NumSamples > 0
                % Fetch index of the interfered signals based on the start time
                % and end time
                if (startTime <= obj.pInterferedSignals(idx).EndTime) && ...
                        endTime >= (obj.pInterferedSignals(idx).StartTime)
                    % Update the index
                    idxs(idxCount) = idx;
                    idxCount = idxCount + 1;
                end
            end
        end
        % Return the interfered indexes
        interferedIdxs = idxs(1:idxCount-1);
    end
    
    function bleWaveform = applyInterference(obj)
    %applyInterference Apply interference on the received signal and
    %returns the interfered waveform
    
        % Received waveform
        bleWaveform = obj.pSignal.Waveform(1:obj.pSignal.NumSamples);
        
        % Get indices of the interfered signals
        idxs = getInterferedIdxs(obj, obj.pSignal.StartTime, obj.pSignal.EndTime);

        % Add interference, if present
        if numel(idxs) > 0
            % Update number of collisions
            obj.TotalCollisions = obj.TotalCollisions + 1;
            % Update other stats of collisions
            if numel(idxs) == 1
                obj.TwoSignalsCollision = obj.TwoSignalsCollision + 1;
            elseif numel(idxs) == 2
                obj.ThreeSignalsCollision = obj.ThreeSignalsCollision + 1;
            elseif numel(idxs) == 3
                obj.FourSignalsCollision = obj.FourSignalsCollision + 1;
            end
            for idx = 1:numel(idxs)
                % Fetch interfered signal
                interferedSignal = obj.pInterferedSignals(idxs(idx));
                
                % Interfered waveform
                interferedWaveform = interferedSignal.Waveform(1:interferedSignal.NumSamples);
                
                % Calculate the interference start time and end time
                interferedStartTime = max(obj.pSignal.StartTime, interferedSignal.StartTime);
                interferedEndTime = min(obj.pSignal.EndTime, interferedSignal.EndTime);
                
                % Calculate the interfered duration in microseconds
                interferenceDuration = interferedEndTime - interferedStartTime;
                
                % Calculate sample duration in microseconds
                sampleDuration = (1/interferedSignal.SampleRate)*1e6;
                
                % Get the start index of the interfered samples
                sampleStartIdx = round((1/sampleDuration)*(abs(obj.pSignal.StartTime - interferedSignal.StartTime))+1);
                % Get end start index of the interfered samples
                sampleEndIdx = round(sampleStartIdx + (1/sampleDuration)*(interferenceDuration))-1;
                
                % Corrupt the interfered samples
                bleWaveform(sampleStartIdx:sampleEndIdx) = bleWaveform(sampleStartIdx:sampleEndIdx) + ...
                    interferedWaveform(sampleStartIdx:sampleEndIdx);
            end
        end
    end
    
    function bleWaveform = applyThermalNoise(obj, bleWaveform, sampleRate)
    %applyThermalNoise Add thermal noise to the received waveform
        
        % Create a thermal noise System object
        thNoise = comm.ThermalNoise('NoiseMethod','Noise figure',...
            'SampleRate',sampleRate,...
            'NoiseFigure',obj.NoiseFigure);
        
        % Add thermal noise to the received waveform
        bleWaveform = thNoise(bleWaveform);
    end
    
    function [pduBitsWithCRC, accessAddress] = decodeWaveform(obj, rxWaveform)
    %decodeWaveform BLE PHY waveform decoder
        
        % Create and configure the receiver System objects
        initRxParams = helperBLEReceiverInit(obj.PHYMode, obj.SamplesPerSymbol, obj.AccessAddress);
        
        % Pass the received waveform to the practical receiver
        [bits, accessAddress] = helperBLEPracticalReceiver(rxWaveform, initRxParams, obj.ChannelIndex);
        
        % Initialize
        pduBitsWithCRC = [];
        octetLen = 8; % Number of bits for an octet
        % Refer Bluetooth Core Specification, version 5.0, volume 6, part
        % B, section 2.1
        crcLen = 3*octetLen;    % Three octets
        % Refer Bluetooth Core Specification, version 5.0, volume 6, part
        % B, section 2.4
        headerLen = 2*octetLen; % Two octets
        
        if(~isempty(bits))
            % Fetch the length field from the decoded bits
            pduLenField = double(bits(9:16)); % Second byte of the PDU header
            % Calculate size of the "payload" field of the LL PDU in bits
            payloadLenInBits = comm.internal.utilities.bi2deRightMSB(pduLenField', 2) * octetLen;
            % Calculate size of the LL PDU (Header | Payload | CRC)
            pduLen = payloadLenInBits + crcLen + headerLen;
            % Fetch the LL PDU from the decoded bits
            if length(bits) >= pduLen
                pduBitsWithCRC = bits(1:pduLen);
            end
        end
    end
end
end
